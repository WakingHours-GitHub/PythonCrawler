"""
re: Regular Expression: 正则表达式, 一种使用表达式的方式对字符串进行匹配的语法规则.
也就是使用一定的规则去匹配我们想要的字符串, 这种数据解析的方式速度是最快的.
我们的目标也就是使用正则在一大串字符串中匹配我们想要的字符串.
正则的语法: 就是使用元字符进行排列组合匹配字符串.
元字符: 具有固定含义的特殊符号
使用这些元字符, 就可以按照规则进行匹配.

常用元字符:
    每个元字符默认只匹配一个字符

    .       匹配换行符以外的任意字符 (除了不匹配换行符, 其他任意字符均匹配)
    \w      匹配字母或数字或下划线
    \s      匹配任意的空白符 (空格,换行,回车)
    \d      匹配数字(匹配数字, digit)
    \n      匹配一个换行符
    \t      匹配一个制表符

    大写符号, 表示非:
    \W      匹配非字母或数字或下划线
    \S      匹配非的空白符
    \D      匹配非数字

    ^       匹配字符串的开始
    $       匹配字符串的结尾
    测试使用用.
    ^\d\d\d 这就表示, 必须是由三个数字开头的.
    \d\d$ 这就表示必须由2个数字结尾的才匹配
    所以: ^\d\d\d$ 这就只匹配三个数字开头并且和三个数字结尾的字符串, 也就是纯数字字符串.

    a|b     匹配字符a或者字符b
    ()      匹配括号内的表达式, 也表示一个组
    [...]   匹配字符组中的所有字符
    [^...]  匹配除了字符组中所有的字符.
        [a-zA-Z0-9]在中括号中'-'表示范围. 从哪到哪.


量词: 控制前面的元字符出现的次数
    例子: \d{5} -> \d\d\d\d\d 就表示5位数字
    *       重复零次或多次
    +       重复一次或多次
    ?       重复0次或者1次, 出现或者不出现
    {n}     重复n次.
    {n,}    重复n次或更多次.
    {n, m}  重复n次到m次.

贪婪匹配和惰性匹配
    .*      贪婪匹配: 尽可能匹配多
        尽可能匹配多的字符.
        匹配最远的字符串.

    .*?     惰性匹配: 尽可能匹配少
        .匹配任意字符; *匹配0次或多次; ?0次或1次. 让*尽可能少的匹配结果, 而*又匹配.(任意字符)也就是匹配任意字符.
        所以意义就是: 尽可能少的匹配字符.
        所以该正则运行过程为: 先找最找的匹配, 然后又由于?所以又往回找, 找最小匹配的. -> 回溯的思想.
        .*?x 就表示x字符串中断. 

re模块:








"""

import re

# list = re.findall(pattern, string, flags): 匹配字符串中的所有符合正则的内容
# 参数分别是: 正则, 要匹配的字符串, 标识 . 返回值是一个列表,匹配到几个就返回列表中的几个元素
lst = re.findall(r"\d+", "我的的电话号是10086 , 我女朋友的电话是10010")
# 为什么要加上r''回顾python基础, r是保留原格式,防止转义
# r -> raw string 标识原始字符串, 意思是该字符串中间的特殊字符不用转义.
print(lst)

# 但是findall()用的并不多,因为如果是一个很长的一个字符串,那么列表的效率并不高
# 列表的效率不高, 但是迭代器效率高,

# iter = finditer(patten, string, flags): 匹配字符串中所有的内容[返回的是迭代器],从迭代器中获取到匹配的内容还需要.group()
# 返回的是match对象迭代器, 而match是一个封装的类型,如果我想要匹配到的结果,还需要.group
iter = re.finditer(r"\d+", "我的的电话号是10086, 我女朋友的电话是10010")
# 从迭代器中获取数据
# for i in iter:
#     print(i)
# 可见迭代器里面的元素是match对象.
# Match.group 就可以得到正则匹配出来的原始数值.
# # <re.Match object; span=(7, 11), match='10086'>
# # <re.Match object; span=(21, 26), match='10010'>

for i in iter:
    print(i.group())
    # 10086
    # 10010


# Match = re.search() # 在待查找的字符串中匹配到一次就返回(证明在里面), 是全文检索, 找到就返回,
# search()返回的是match对象, 所以也需要.group, 但是search是匹配到一次.
s = re.search(r"\d+", "我的的电话号是10086, 我女朋友的电话是10010")
# 返回的是match对象, 所以我们仍然需要.group()
print(s.group())

# re.match # 在待查找的字符串中匹配到一次就返回(证明在里面),是开头查找
# match是从头开始匹配. 只有从第一个字符匹配上个, match才能返回结果.
## re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
# s1 = re.match(r"\d+", "我的的电话号是10086, 我女朋友的电话是10010")
# print(s1.group()) # 'NoneType' object has no attribute 'group'
s1 = re.match(r"\d+", "10086, 我女朋友的电话是10010")
print(s1.group())


# 预加载正则表达式
# 正则可能会很长, 并且每个正则可能需要匹配不同的需求, 需要经常使用, 因此有预加载选项.
# re.compile(pattern) 返回一个正则对象. 这个正则对象就表示着我们的正则表达式.
obj = re.compile(r"\d+")  # 预加载, 可以提升一点点效率, 并且可以反复使用
# 我们可以直接使用obj.find(str)去匹配.
# 当正则很长的时候,这也可以复用
ret = obj.finditer("我的的电话号是10086, 我女朋友的电话是10010")
print(ret) # 仍然是迭代器.
for it in ret:
    print(it.group())

# 预加载的好处就是方便复用.


# 接下来比较重要的内容,单独提取正则中的具体内容
# 刚才是从str中利用正则对比, 现在我想从匹配出来的正则中, 继续匹配出来单独的结果.
s = """
<div class='⻄游记'><span id='10010'>中国联通</span></div>
<div class='报菜名'><span id='10'>郭德纲</span></div>
<div class='艺术漫谈'><span id='103'>于谦</span></div>
<div class='tory'><span id='123'>胡说八道</span></div>
<div class='中国5g'><span id='10086'>中国移动</span></div>
"""
# 我想取出来后面的中文字符
# 也就是在正则匹配到的结果中, 单独取出我想要的组的内容,接下来我们来实操一下

# 预加载
# compile = re.compile(pattern, flags) # 返回一个预加载对象
obj = re.compile(r"<div class='.*?'><span id='\d+'>.*?</span></div>",re.S) # 后面是得选择的参数
print("obj", obj)
# re.S就是让.也匹配换行符, 此时.可以匹配所有的字符了, 此时打印出来也就连贯了
# flags = re.S, 作用: 让.能匹配换行符, 防止数据断.
result = obj.finditer(s)  # iter返回一个迭代器
for i in result:
    print(i.group())

# 把s字符串都打印出来了
# 但是我只想要特定的那些字符,或者特定位置上元素.我们该怎么做
# 也就是从匹配到的内容中, 再提取出我们想要(特定)的元素.

obj = re.compile(r"<div class='.*?'><span id='(?P<id>\d+)'>(?P<name>.*?)</span></div>")
# 这句话的意思就是将（.*?)中匹配到的内容放在一个组里面
# (?P<名字>正则表达式) # 这就是将该正则表达式所匹配到的一个内容, 放到一个组里面去.
# 然后打印时, Match对象.group("组名") 从那个组里面拿结果.
result = obj.finditer(s)
for it in result:
    print(it.group("name"))
    print(it.group("id"))

# 语法
# (?P<分组名字>正则) 可以单独将从正则匹配到的内容中提取到XXX名字的内容
# 注意P要大写
